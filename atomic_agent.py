import os
import json
from datetime import date
from dotenv import load_dotenv
import openai
import instructor
from pydantic import Field
from prompts import role, goal, instructions, knowledge

# Atomic Agents imports
from atomic_agents import AtomicAgent, AgentConfig, BaseIOSchema, BaseTool
from atomic_agents.context import ChatHistory, SystemPromptGenerator

# Tavily client for web search
from tavily import TavilyClient

# Load environment variables and initialize Tavily client
load_dotenv()
tavily_api_key = os.getenv("TAVILY_API_KEY")
tavily_client = TavilyClient(api_key=tavily_api_key)

# Schemas with required docstrings
class OrchestratorInputSchema(BaseIOSchema):
    """Input schema for the Orchestrator Agent. Contains the user's message to be processed."""
    chat_message: str = Field(..., description="The user's input message to be analyzed and responded to.")

class OrchestratorOutputSchema(BaseIOSchema):
    """Combined output schema for the Orchestrator Agent. Contains the tool to use and its parameters."""
    tool: str = Field(..., description="The tool to use.")
    tool_parameters: dict = Field(default_factory=dict)

class FinalAnswerSchema(BaseIOSchema):
    """Schema for the final answer generated by the Orchestrator Agent.
    A response that addresses the user's query, giving high precedence to tool outputs.
    """
    final_answer: str = Field(..., description="A response that addresses the user's query, giving high precedence to tool outputs.")

class DateToolOutputSchema(BaseIOSchema):
    """Output schema for the date tool. A string representation of the date."""
    result: str = Field(..., description="Today's date as a well formatted string.")

class WebSearchToolInputSchema(BaseIOSchema):
    """Schema for the web search tool. Contains the query to use for the web search."""
    query: str = Field(..., description="The query to be used for the search.")

class WebSearchToolOutputSchema(BaseIOSchema):
    """Output Schema for the web search tool. A string containing the search results."""
    results: str = Field(..., description="The search results.")

class SystemMessageSchema(BaseIOSchema):
    """Schema for system messages added to chat history."""
    message: str = Field(..., description="The system message content.")

class Agent:
    def __init__(self, model: str = "gpt-4o-mini"):
        """
        Initialize the Atomic Agents-based agent.
        """
        self.name = "Atomic Agent"
        self.client = instructor.from_openai(
            openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        )
        self.system_prompt = SystemPromptGenerator(
            background=[role, goal, knowledge],
            steps=[
                "Understand the user's input and provide a relevant response.",
                "Respond to the user."
            ],
            output_instructions=[
                instructions,
                "***IMPORTANT***: When selecting a tool, make sure to adhere to the schema."
            ],
        )
        self.tools = self._create_tools()
        # Create two agents for v2.0 - one for tool selection, one for final answers
        self.orchestrator_agent = self._create_orchestrator_agent(model)
        self.answer_agent = self._create_answer_agent(model)

    @staticmethod
    def date_tool() -> str:
        """
        Get the current date.
        """
        today = date.today().strftime("%B %d, %Y")
        return f"Today's date is: {today}"

    @staticmethod
    def web_search(query: str) -> str:
        """
        Search the web for the given query and return the results as a JSON string.
        """
        search_response = tavily_client.search(query)
        return json.dumps(search_response.get('results', []))

    def _create_tools(self) -> dict:
        """
        Create the tools for the agent.
        """
        agent = self

        class DateTool(BaseTool):
            """ Tool for looking up today's date.  Should be used to establish context."""
            input_schema = BaseIOSchema
            output_schema = DateToolOutputSchema

            def run(self, params=None):
                return DateToolOutputSchema(result=agent.date_tool())

        class WebSearchTool(BaseTool):
            """ Tool to perform web searches. Can be used to augment your knowledge."""
            input_schema = WebSearchToolInputSchema
            output_schema = WebSearchToolOutputSchema

            def run(self, params):
                results = agent.web_search(params.query)
                return WebSearchToolOutputSchema(results=results)

        return {"date": DateTool(), "web_search": WebSearchTool()}

    def _create_orchestrator_agent(self, model: str) -> AtomicAgent:
        """
        Create the orchestrator agent for tool selection.
        """
        config = AgentConfig(
            client=self.client,
            model=model,
            system_prompt_generator=self.system_prompt,
            history=ChatHistory(),
        )
        return AtomicAgent[OrchestratorInputSchema, OrchestratorOutputSchema](config)

    def _create_answer_agent(self, model: str) -> AtomicAgent:
        """
        Create the answer agent for generating final responses.
        """
        config = AgentConfig(
            client=self.client,
            model=model,
            system_prompt_generator=self.system_prompt,
            history=ChatHistory(),
        )
        return AtomicAgent[OrchestratorInputSchema, FinalAnswerSchema](config)

    def chat(self, message: str) -> str:
        """
        Process a chat message and return the agent's response.
        """
        try:
            input_schema = OrchestratorInputSchema(chat_message=message)

            # Use orchestrator agent to select tool
            tool_selection = self.orchestrator_agent.run(input_schema)

            # Execute the selected tool and add output to both agents' histories
            if tool_selection.tool == "date":
                tool_output = self.tools["date"].run()
                tool_message = SystemMessageSchema(message=f"Date tool result: {tool_output.result}")
                self.orchestrator_agent.history.add_message("system", tool_message)
                self.answer_agent.history.add_message("system", tool_message)
            elif tool_selection.tool == "web_search":
                params = WebSearchToolInputSchema(
                    query=tool_selection.tool_parameters.get('query', message)
                )
                tool_output = self.tools["web_search"].run(params)
                tool_message = SystemMessageSchema(message=f"Web search results: {tool_output.results}")
                self.orchestrator_agent.history.add_message("system", tool_message)
                self.answer_agent.history.add_message("system", tool_message)
            else:
                # No tool needed
                no_tool_message = SystemMessageSchema(message="No tool is needed to answer this question.")
                self.orchestrator_agent.history.add_message("system", no_tool_message)
                self.answer_agent.history.add_message("system", no_tool_message)

            # Use answer agent to generate final response
            final_answer = self.answer_agent.run(input_schema)

            return final_answer.final_answer

        except Exception as e:
            print(f"Error in chat: {e}")
            return "Sorry, I encountered an error processing your request."

    def clear_chat(self) -> bool:
        """
        Reset the conversation context.
        """
        try:
            # Reset both agents' histories
            self.orchestrator_agent.history = ChatHistory()
            self.answer_agent.history = ChatHistory()
            return True
        except Exception as e:
            print(f"Error clearing chat: {e}")
            return False

def main() -> None:
    """
    Example usage demonstrating the agent interface.
    """
    agent = Agent()
    while True:
        query = input("You: ")
        if query.lower() in ['exit', 'quit']:
            break
        response = agent.chat(query)
        print(f"Assistant: {response}")

if __name__ == "__main__":
    main()
